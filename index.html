<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>KityMinder Editor - Powered By FEX</title>
	<link href="favicon.ico" type="image/x-icon" rel="shortcut icon">
	<!-- bower:css -->
	<link rel="stylesheet" href="./bower_components/bootstrap/dist/css/bootstrap.css" />
	<link rel="stylesheet" href="./bower_components/codemirror/lib/codemirror.css" />
	<link rel="stylesheet" href="./bower_components/hotbox/hotbox.css" />
	<link rel="stylesheet" href="./bower_components/kityminder-core/dist/kityminder.core.css" />
	<link rel="stylesheet" href="./bower_components/color-picker/dist/color-picker.min.css" />
	<!-- endbower -->

	<link rel="stylesheet" href="kityminder.editor.min.css">
	<style>
		html, body {
			margin: 0;
			padding: 0;
			height: 100%;
			overflow: hidden;
		}
		div.minder-editor-container {
			position: absolute;
			top: 0px;
			bottom: 0;
			left: 0;
			right: 0;
		}
	</style>
</head>
<body ng-app="kityminderDemo" ng-controller="MainController">
<kityminder-editor on-init="initEditor(editor, minder)" data-theme="fresh-green"></kityminder-editor>
<iframe name="frameFile" style="display:none;"></iframe>
</body>

<!-- bower:js -->
<script src="./bower_components/jquery/dist/jquery.js"></script>
<script src="./bower_components/bootstrap/dist/js/bootstrap.js"></script>
<script src="./bower_components/angular/angular.js"></script>
<script src="./bower_components/angular-bootstrap/ui-bootstrap-tpls.js"></script>
<script src="./bower_components/codemirror/lib/codemirror.js"></script>
<script src="./bower_components/codemirror/mode/xml/xml.js"></script>
<script src="./bower_components/codemirror/mode/javascript/javascript.js"></script>
<script src="./bower_components/codemirror/mode/css/css.js"></script>
<script src="./bower_components/codemirror/mode/htmlmixed/htmlmixed.js"></script>
<script src="./bower_components/codemirror/mode/markdown/markdown.js"></script>
<script src="./bower_components/codemirror/addon/mode/overlay.js"></script>
<script src="./bower_components/codemirror/mode/gfm/gfm.js"></script>
<script src="./bower_components/angular-ui-codemirror/ui-codemirror.js"></script>
<script src="./bower_components/marked/lib/marked.js"></script>
<script src="./bower_components/kity/dist/kity.min.js"></script>
<script src="./bower_components/hotbox/hotbox.js"></script>
<script src="./bower_components/json-diff/json-diff.js"></script>
<script src="./bower_components/kityminder-core/dist/kityminder.core.min.js"></script>
<script src="./bower_components/color-picker/dist/color-picker.min.js"></script>
<!-- endbower -->
<script src="kityminder.editor.min.js"></script>
<script>
	angular.module('kityminderDemo', ['kityminderEditor'])
	.controller('MainController', function($scope) {
		$scope.initEditor = function(editor, minder) {
			window.editor = editor;
			window.minder = minder;
		};
	});
	
	var content='{"root":{"data":{"id":"c45g9y4pxw80","created":1594638796982,"text":"Android","expandState":"expand"},"children":[{"data":{"id":"c45gakc62sg0","created":1594638845322,"text":"NDK","layout":null,"expandState":"collapse"},"children":[{"data":{"id":"c45hfe0siqg0","created":1594642044504,"text":"C语言","expandState":"collapse"},"children":[{"data":{"id":"c45hfr89yc00","created":1594642073255,"text":"基本数据类型"},"children":[]},{"data":{"id":"c45hfu418m80","created":1594642079529,"text":"输入输出"},"children":[]},{"data":{"id":"c45hfwr4zjk0","created":1594642085279,"text":"指针"},"children":[]},{"data":{"id":"c45hfywt8zc0","created":1594642089976,"text":"指针类型"},"children":[]},{"data":{"id":"c45hg2kfu3c0","created":1594642097935,"text":"空指针"},"children":[]},{"data":{"id":"c45hg8no7zs0","created":1594642111191,"text":"二级指针"},"children":[]},{"data":{"id":"c45hgbjxbgw0","created":1594642117495,"text":"指针运算"},"children":[]},{"data":{"id":"c45hgd21h2g0","created":1594642120767,"text":"指针与数组"},"children":[]},{"data":{"id":"c45hgg8h9vk0","created":1594642127687,"text":"结构体"},"children":[]},{"data":{"id":"c45hggjvcbc0","created":1594642128375,"text":"指针"},"children":[]},{"data":{"id":"c45hggp0y3k0","created":1594642128687,"text":"联合体"},"children":[]},{"data":{"id":"c45hggs36ko0","created":1594642128872,"text":"IO"},"children":[]},{"data":{"id":"c45hgguvk940","created":1594642129041,"text":"预编译指令"},"children":[]},{"data":{"id":"c45hggxivmw0","created":1594642129201,"text":"JNI开发流程"},"children":[]},{"data":{"id":"c45hgh0ajfk0","created":1594642129368,"text":"JNIEnv"},"children":[]},{"data":{"id":"c45hgh36f400","created":1594642129543,"text":"JNI数据类型"},"children":[]},{"data":{"id":"c45hgh61tio0","created":1594642129717,"text":"JNI异常处理"},"children":[]},{"data":{"id":"c45hgh8a1280","created":1594642129851,"text":"JNI缓存策略"},"children":[]},{"data":{"id":"c45hghar1yw0","created":1594642130001,"text":"JNI加解密"},"children":[]},{"data":{"id":"c45hghdfhv40","created":1594642130163,"text":"JNI文件拆分"},"children":[]},{"data":{"id":"c45hh95znns0","created":1594642190663,"text":"JNI文件合并"},"children":[]},{"data":{"id":"c45hh9940d40","created":1594642190851,"text":"增量更新"},"children":[{"data":{"id":"c45hhfgd6hc0","created":1594642204351,"text":"差分包生成"},"children":[]},{"data":{"id":"c45hhjzhyhk0","created":1594642214215,"text":"文件合并"},"children":[]}]},{"data":{"id":"c45hh9c4d3k0","created":1594642191033,"text":"C与C++ 的关系"},"children":[]},{"data":{"id":"c45hh9f5qxc0","created":1594642191217,"text":"C   和C的引用关系"},"children":[]},{"data":{"id":"c45hh9hnho00","created":1594642191368,"text":"构造函数"},"children":[]},{"data":{"id":"c45hh9ka5t40","created":1594642191527,"text":"析构函数"},"children":[]},{"data":{"id":"c45hh9mwzso0","created":1594642191686,"text":"拷贝函数"},"children":[]},{"data":{"id":"c45hh9p9ceg0","created":1594642191828,"text":"静态成员"},"children":[]},{"data":{"id":"c45hi3o989s0","created":1594642257071,"text":"this指针"},"children":[]},{"data":{"id":"c45hi3r8s9s0","created":1594642257251,"text":"友元函数"},"children":[]},{"data":{"id":"c45hi3ub6ls0","created":1594642257437,"text":"运算符重载函"},"children":[]},{"data":{"id":"c45hib1woog0","created":1594642273134,"text":"动态内存分配"},"children":[]},{"data":{"id":"c45hib4y8fk0","created":1594642273318,"text":"字符串"},"children":[]},{"data":{"id":"c45hifa7xns0","created":1594642282343,"text":"OOP继承"},"children":[]}]},{"data":{"id":"c45hfj0laa80","created":1594642055376,"text":"Linux"},"children":[]},{"data":{"id":"c45hfm24sug0","created":1594642061999,"text":"Makefile","expandState":"collapse"},"children":[{"data":{"id":"c45hilw7ox40","created":1594642296734,"text":"Application.mk"},"children":[]},{"data":{"id":"c45hioyp49k0","created":1594642303414,"text":"Android.mk"},"children":[]},{"data":{"id":"c45hirctsnc0","created":1594642308622,"text":"Cmake","expandState":"collapse"},"children":[{"data":{"id":"c45hitvu7s00","created":1594642314126,"text":"cmake命令练习"},"children":[]},{"data":{"id":"c45hiwucq8o0","created":1594642320566,"text":"cmake命令"},"children":[]}]}]}]},{"data":{"id":"c45galz12fc0","created":1594638848881,"text":"数据结构","layout":null,"expandState":"collapse"},"children":[{"data":{"id":"c45hjdz17u80","created":1594642357854,"text":"数据结构","expandState":"collapse"},"children":[{"data":{"id":"c45hjzsecyo0","created":1594642405342,"text":"物理","expandState":"collapse"},"children":[{"data":{"id":"c45hk5u1d5s0","created":1594642418502,"text":"顺序结构"},"children":[]},{"data":{"id":"c45hk6r4jtc0","created":1594642420503,"text":"链式存储结构"},"children":[]}]},{"data":{"id":"c45hk2n29dc0","created":1594642411550,"text":"逻辑","expandState":"collapse"},"children":[{"data":{"id":"c45hkbbtpp40","created":1594642430462,"text":"集合结构"},"children":[]},{"data":{"id":"c45hkc9q3kw0","created":1594642432511,"text":"线性结构"},"children":[]},{"data":{"id":"c45hkcbzt000","created":1594642432649,"text":"树形结构"},"children":[]},{"data":{"id":"c45hkcesvu00","created":1594642432818,"text":"图形结构"},"children":[]}]}]},{"data":{"id":"c45hjl8klag0","created":1594642373669,"text":"线性表","expandState":"collapse"},"children":[{"data":{"id":"c45hkrhny3s0","created":1594642465643,"text":"注解","expandState":"collapse"},"children":[{"data":{"id":"c45hldprlrc0","created":1594642514022,"text":"存储位置连续，可以很方便计算各个元素的地址 如每个元素占C个存储单元"},"children":[]}]},{"data":{"id":"c45hkrxll540","created":1594642466607,"text":"优点","expandState":"collapse"},"children":[{"data":{"id":"c45hlgx4mag0","created":1594642520998,"text":"查询很快"},"children":[]}]},{"data":{"id":"c45hks0njg80","created":1594642466791,"text":"缺点","expandState":"collapse"},"children":[{"data":{"id":"c45hljlufa00","created":1594642526846,"text":"插入和删除效率慢"},"children":[]}]},{"data":{"id":"c45hks35uqg0","created":1594642466943,"text":"Collection","expandState":"collapse"},"children":[{"data":{"id":"c45hln1tu7c0","created":1594642534343,"text":"List","expandState":"collapse"},"children":[{"data":{"id":"c45hlq2z8uo0","created":1594642540943,"text":"备注","expandState":"collapse"},"children":[{"data":{"id":"c45hm72m06w0","created":1594642577926,"text":"查询多用","expandState":"collapse"},"children":[{"data":{"id":"c45hm9ls5bc0","created":1594642583438,"text":"ArrayList"},"children":[]}]},{"data":{"id":"c45hmb06l7k0","created":1594642586486,"text":"增删多用","expandState":"collapse"},"children":[{"data":{"id":"c45hmg8162w0","created":1594642597845,"text":"LinkedList"},"children":[]}]},{"data":{"id":"c45hmdu759c0","created":1594642592654,"text":" 两者都多用","expandState":"collapse"},"children":[{"data":{"id":"c45hmkchm000","created":1594642606821,"text":"ArrayList"},"children":[]}]}]},{"data":{"id":"c45hlv7t1og0","created":1594642552118,"text":"对比","expandState":"collapse"},"children":[{"data":{"id":"c45hmrqu2ww0","created":1594642622926,"text":" Vector和ArrayList的区别","expandState":"collapse"},"children":[{"data":{"id":"c45hmy2na8w0","created":1594642636701,"text":" Vector是线程安全的,效率低"},"children":[]},{"data":{"id":"c45hn0xl6yg0","created":1594642642925,"text":" ArrayList是线程不安全的,效率高"},"children":[]}]},{"data":{"id":"c45hmsf83a80","created":1594642624401,"text":"ArrayList和LinkedList的区别","expandState":"collapse"},"children":[{"data":{"id":"c45hn3ggurs0","created":1594642648421,"text":"ArrayList底层是数组结果,查询和修改快"},"children":[]},{"data":{"id":"c45hn4m6ez40","created":1594642650943,"text":"LinkedList底层是链表结构的,增和删比较快,查询和修改比较慢"},"children":[]}]}]},{"data":{"id":"c45hlvbww3s0","created":1594642552367,"text":"ArrayList","expandState":"collapse"},"children":[{"data":{"id":"c45hnavc04w0","created":1594642664557,"text":" 底层数据结构是数组，查询快，增删慢。线程不安全，效率高。"},"children":[]}]},{"data":{"id":"c45hlveqr800","created":1594642552538,"text":"Vector","expandState":"collapse"},"children":[{"data":{"id":"c45hnds8src0","created":1594642670901,"text":"底层数据结构是数组，查询快，增删慢。线程安全，效率低"},"children":[]}]},{"data":{"id":"c45hm3vn2oo0","created":1594642570974,"text":"LinkedList","expandState":"collapse"},"children":[{"data":{"id":"c45hnga3f7k0","created":1594642676333,"text":"底层数据结构是链表，查询慢，增删快。线程不安全，效率高。"},"children":[]}]}]},{"data":{"id":"c45hlrfdxk00","created":1594642543870,"text":"Set","expandState":"collapse"},"children":[{"data":{"id":"c45hnja6so00","created":1594642682869,"text":"TreeSet"},"children":[]},{"data":{"id":"c45hnjiuiq80","created":1594642683393,"text":"HashSet"},"children":[]}]}]},{"data":{"id":"c45hks5vhf40","created":1594642467107,"text":"栈Stack","expandState":"collapse"},"children":[{"data":{"id":"c45hnp6x5ww0","created":1594642695733,"text":"注释","expandState":"collapse"},"children":[{"data":{"id":"c45hnx2uixs0","created":1594642712901,"text":"栈是限定仅在表尾进行插入和删除操作的线性表"},"children":[]},{"data":{"id":"c45hnxa4ft40","created":1594642713340,"text":"允许插入和删除的一端为栈顶，另一端称为栈底"},"children":[]},{"data":{"id":"c45hnxci7340","created":1594642713484,"text":"不含任何数据元素的栈称为空栈"},"children":[]},{"data":{"id":"c45hnxfi6g00","created":1594642713666,"text":"栈又称为后进先出的线性表"},"children":[]},{"data":{"id":"c45hnxi2vzs0","created":1594642713822,"text":"Stack是线程安全的"},"children":[]}]},{"data":{"id":"c45hnqn14800","created":1594642698884,"text":"Stack","expandState":"collapse"},"children":[{"data":{"id":"c45ho84yqns0","created":1594642736973,"text":"push","expandState":"collapse"},"children":[{"data":{"id":"c45hogywd4o0","created":1594642756197,"text":"入栈"},"children":[]}]},{"data":{"id":"c45ho8cxdwo0","created":1594642737455,"text":"pop","expandState":"collapse"},"children":[{"data":{"id":"c45hohzjrm00","created":1594642758413,"text":"出栈"},"children":[]}]},{"data":{"id":"c45ho8fv5d40","created":1594642737632,"text":"peek","expandState":"collapse"},"children":[{"data":{"id":"c45hoiurbw00","created":1594642760301,"text":"获取栈顶元素"},"children":[]}]},{"data":{"id":"c45ho8ifptk0","created":1594642737788,"text":"enpty","expandState":"collapse"},"children":[{"data":{"id":"c45hojwh0s80","created":1594642762581,"text":"判断是否为空栈"},"children":[]}]},{"data":{"id":"c45ho8mgqyo0","created":1594642738031,"text":"search ","expandState":"collapse"},"children":[{"data":{"id":"c45hoks36ao0","created":1594642764493,"text":"查询栈内元素位置"},"children":[]}]}]},{"data":{"id":"c45hnqqc8ww0","created":1594642699084,"text":"逆波兰表达式"},"children":[]}]},{"data":{"id":"c45hks8mh7s0","created":1594642467273,"text":"队列Queue","expandState":"collapse"},"children":[{"data":{"id":"c45hp3fdwoo0","created":1594642805084,"text":"注释","expandState":"collapse"},"children":[{"data":{"id":"c45hphgjy2g0","created":1594642835629,"text":"队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表"},"children":[]},{"data":{"id":"c45hphn71gg0","created":1594642836031,"text":"允许删除的一端称为队头（Front）"},"children":[]},{"data":{"id":"c45hphq30uw0","created":1594642836205,"text":"允许插入的一端称为队尾"},"children":[]},{"data":{"id":"c45hpht20go0","created":1594642836385,"text":"当队列中没有元素时称为空队列"},"children":[]},{"data":{"id":"c45hphuhfzs0","created":1594642836471,"text":"队列亦称作先进先出（First In First Out）的线性表，简称为FIFO表"},"children":[]},{"data":{"id":"c45hphwj7uw0","created":1594642836595,"text":"队列的修改是依先进先出的原则进行的。新来的成员总是加入队尾（即不允许\"加塞\"），每次离开的成员总是队列头上的（不允许中途离队），即当前\"最老的\"成员离队 "},"children":[]}]},{"data":{"id":"c45hp3odzqo0","created":1594642805628,"text":"基本逻辑运算","expandState":"collapse"},"children":[{"data":{"id":"c45hpvdkzuw0","created":1594642865924,"text":"InitQueue","expandState":"collapse"},"children":[{"data":{"id":"c45hq9o9o680","created":1594642897045,"text":"置空队。构造一个空队列Q"},"children":[]}]},{"data":{"id":"c45hpvlh2sg0","created":1594642866402,"text":"QueueEmpty","expandState":"collapse"},"children":[{"data":{"id":"c45hqcfv4nc0","created":1594642903068,"text":"判队空。若队列Q为空，则返回真值，否则返回假值"},"children":[]}]},{"data":{"id":"c45hpvnrerk0","created":1594642866540,"text":"QueueFull","expandState":"collapse"},"children":[{"data":{"id":"c45hqftpx5c0","created":1594642910436,"text":"判队满。若队列Q为满，则返回真值，否则返回假值。"},"children":[]}]},{"data":{"id":"c45hpvpxdzk0","created":1594642866671,"text":"EnQueue","expandState":"collapse"},"children":[{"data":{"id":"c45hqingz080","created":1594642916588,"text":"若队列Q非满，则将元素x插入Q的队尾。此操作简称入队"},"children":[]}]},{"data":{"id":"c45hpvsryg00","created":1594642866843,"text":"DeQueue","expandState":"collapse"},"children":[{"data":{"id":"c45hqlomgag0","created":1594642923188,"text":"若队列Q非空，则删去Q的队头元素，并返回该元素。此操作简称出队"},"children":[]}]},{"data":{"id":"c45hpvwce6w0","created":1594642867059,"text":"QueueFront ","expandState":"collapse"},"children":[{"data":{"id":"c45hqpx1fwg0","created":1594642932404,"text":"若队列Q非空，则返回队头元素，但不改变队列Q的状态"},"children":[]}]}]},{"data":{"id":"c45hp3r78a00","created":1594642805798,"text":"循环队列"},"children":[]},{"data":{"id":"c45hp3u1w1c0","created":1594642805970,"text":"链队列","expandState":"collapse"},"children":[{"data":{"id":"c45hqv9jid40","created":1594642944044,"text":"链队列的定义","expandState":"collapse"},"children":[{"data":{"id":"c45hr0j99qw0","created":1594642955516,"text":"队列的链式存储结构简称为链队列。它是限制仅在表头删除和表尾插入的单链表"},"children":[]}]},{"data":{"id":"c45hqvpbtr40","created":1594642944999,"text":"链队列的结构类型说明","expandState":"collapse"},"children":[{"data":{"id":"c45hr46dqw80","created":1594642963444,"text":"增加指向链表上的最后一个结点的尾指针，便于在表尾做插入操作"},"children":[]},{"data":{"id":"c45hr4pjuxs0","created":1594642964603,"text":"Q为LinkQueue型的指针"},"children":[]}]}]},{"data":{"id":"c45hp4mj7u80","created":1594642807692,"text":"顺序队列","expandState":"collapse"},"children":[{"data":{"id":"c45hr9op6000","created":1594642975436,"text":"顺序队列的定义","expandState":"collapse"},"children":[{"data":{"id":"c45hrjsodr40","created":1594642997444,"text":"队列的顺序存储结构称为顺序队列，顺序队列实际上是运算受限的顺序表"},"children":[]}]},{"data":{"id":"c45hr9wr35k0","created":1594642975923,"text":" 顺序队列的表示","expandState":"collapse"},"children":[{"data":{"id":"c45hrm5mlxs0","created":1594643002581,"text":"和顺序表一样，顺序队列用一个向量空间来存放当前队列中的元素"},"children":[]},{"data":{"id":"c45hrmggwtc0","created":1594643003236,"text":"由于队列的队头和队尾的位置是变化的，设置两个指针front和rear分别指示队头元素和队尾元素在向量空间中的位置，它们的初值在队列初始化时均应置为0"},"children":[]}]},{"data":{"id":"c45hr9zchg00","created":1594642976079,"text":"顺序队列的基本操作","expandState":"collapse"},"children":[{"data":{"id":"c45hrskcpm00","created":1594643016532,"text":"注意","expandState":"collapse"},"children":[{"data":{"id":"c45hrssl9bc0","created":1594643017030,"text":"当头尾指针相等时，队列为空"},"children":[]}]},{"data":{"id":"c45hryhrge80","created":1594643029436,"text":"入队时：将新元素插入rear所指的位置，然后将rear加1"},"children":[]},{"data":{"id":"c45hryp8h200","created":1594643029888,"text":"出队时：删去front所指的元素，然后将front加1并返回被删元素"},"children":[]}]},{"data":{"id":"c45hra297ww0","created":1594642976255,"text":"顺序队列中的溢出现象","expandState":"collapse"},"children":[{"data":{"id":"c45hs3dgy8o0","created":1594643040060,"text":"\"下溢\"现象","expandState":"collapse"},"children":[{"data":{"id":"c45hsb7enlc0","created":1594643057108,"text":"当队列为空时，做出队运算产生的溢出现象。“下溢”是正常现象，常用作程序控制转移的条件。"},"children":[]}]},{"data":{"id":"c45hs3oeq1s0","created":1594643040722,"text":"\"真上溢\"现象","expandState":"collapse"},"children":[{"data":{"id":"c45hsef65rc0","created":1594643064108,"text":"当队列满时，做进栈运算产生空间溢出的现象。“真上溢”是一种出错状态，应设法避免。"},"children":[]}]},{"data":{"id":"c45hs3roo280","created":1594643040920,"text":"\"假上溢\"现象 ","expandState":"collapse"},"children":[{"data":{"id":"c45hsj180s80","created":1594643074148,"text":"说明","expandState":"collapse"},"children":[{"data":{"id":"c45hslsbji00","created":1594643080140,"text":"由于入队和出队操作中，头尾指针只增加不减小，致使被删元素的空间永远无法重新利用。当队列中实际的元素个数远远小于向量空间的规模时，也可能由于尾指针已超越向量空间的上界而不能做入队操作。该现象称为\"假上溢\"现象"},"children":[]}]},{"data":{"id":"c45hsnj14wo0","created":1594643083932,"text":"解决办法","expandState":"collapse"},"children":[{"data":{"id":"c45hsu6rgso0","created":1594643098428,"text":"改为循环队列"},"children":[]},{"data":{"id":"c45hsug77z40","created":1594643098998,"text":"我们去掉一个指针，只有一个指针，这样的话把数组想象成一个圆环，从0到MaxSize-1"},"children":[]}]}]}]}]}]},{"data":{"id":"c45hksbucug0","created":1594642467468,"text":"链表"},"children":[]}]},{"data":{"id":"c45hjnnigdc0","created":1594642378926,"text":"链式存储","layout_right_offset":{"x":2,"y":-21},"expandState":"collapse"},"children":[{"data":{"id":"c45htzksl9c0","created":1594643188524,"text":"Map","expandState":"collapse","layout_right_offset":{"x":12,"y":-57}},"children":[{"data":{"id":"c45htfalmgo0","created":1594643144372,"text":"HashMap","layout_right_offset":{"x":3,"y":199},"expandState":"collapse"},"children":[{"data":{"id":"c45htr70vcw0","created":1594643170277,"text":"LinkedHashMap"},"children":[]},{"data":{"id":"c45htrh5weo0","created":1594643170890,"text":"LruCache "},"children":[]}]},{"data":{"id":"c45ht7q6hcg0","created":1594643127900,"text":"注解","layout_right_offset":{"x":-10,"y":-50},"expandState":"collapse"},"children":[{"data":{"id":"c45htjzt9aw0","created":1594643154604,"text":"链式存储的特点是用一组任意存储单元存储线 性结构的数据元素  可以是连续 也可以是不连续的"},"children":[]}]},{"data":{"id":"c45ht7wkzo00","created":1594643128287,"text":"优点","layout_right_offset":{"x":-2,"y":-41},"expandState":"collapse"},"children":[{"data":{"id":"c45htm8nho80","created":1594643159492,"text":"增删快 "},"children":[]}]},{"data":{"id":"c45ht89x4k00","created":1594643129094,"text":"缺点","layout_right_offset":{"x":4,"y":-36},"expandState":"collapse"},"children":[{"data":{"id":"c45htoxwmy80","created":1594643165372,"text":"查询慢,修改也慢"},"children":[]}]},{"data":{"id":"c45ht8gv7o00","created":1594643129514,"text":"TreeMap ","layout_right_offset":{"x":1,"y":-32}},"children":[]}]}]},{"data":{"id":"c45hjnq5x4o0","created":1594642379086,"text":"链表","expandState":"collapse"},"children":[{"data":{"id":"c45huv2aqf40","created":1594643257063,"text":"双向链表","expandState":"collapse"},"children":[{"data":{"id":"c45hv05qkg80","created":1594643268155,"text":"说明","expandState":"collapse"},"children":[{"data":{"id":"c45hv4iwvk00","created":1594643277659,"text":"有两个指针，一个指向前一个节点，一个后一个节点。"},"children":[]}]},{"data":{"id":"c45hv0gxgqg0","created":1594643268831,"text":"优点","expandState":"collapse"},"children":[{"data":{"id":"c45hvb8xgpk0","created":1594643292292,"text":"可以找到前驱和后继，可进可退；"},"children":[]}]},{"data":{"id":"c45hv0ixrpc0","created":1594643268953,"text":"缺点","expandState":"collapse"},"children":[{"data":{"id":"c45hvjvka3k0","created":1594643311075,"text":"增加删除节点复杂，需要多分配一个指针存储空间。"},"children":[]}]},{"data":{"id":"c45hv0ljms80","created":1594643269111,"text":"适用","expandState":"collapse"},"children":[{"data":{"id":"c45hvnwpaw80","created":1594643319851,"text":"适用于需要双向查找节点值的情况"},"children":[]}]}]},{"data":{"id":"c45huvb5hhc0","created":1594643257598,"text":"单向链表","expandState":"collapse"},"children":[{"data":{"id":"c45hvt8sxoo0","created":1594643331467,"text":"说明","expandState":"collapse"},"children":[{"data":{"id":"c45hvtbzc0w0","created":1594643331659,"text":"只有一个指向下一个节点的指针"},"children":[]}]},{"data":{"id":"c45hvzm823c0","created":1594643345339,"text":"优点","expandState":"collapse"},"children":[{"data":{"id":"c45hw36191k0","created":1594643353067,"text":"单向链表增加删除节点简单。遍历时候不会死循环"},"children":[]}]},{"data":{"id":"c45hw1097sg0","created":1594643348364,"text":"缺点","expandState":"collapse"},"children":[{"data":{"id":"c45hw6d9uuw0","created":1594643360035,"text":"只能从头到尾遍历。只能找到后继，无法找到前驱，也就是只能前进。"},"children":[]}]},{"data":{"id":"c45hvzpnd5s0","created":1594643345546,"text":"适用","expandState":"collapse"},"children":[{"data":{"id":"c45hwa9ip000","created":1594643368515,"text":"适用于节点的增加删除。"},"children":[]}]}]}]},{"data":{"id":"c45hjntafg00","created":1594642379275,"text":"树","expandState":"collapse"},"children":[{"data":{"id":"c45hwo6f3kw0","created":1594643398803,"text":"节点的度","expandState":"collapse"},"children":[{"data":{"id":"c45hxpc0src0","created":1594643479683,"text":"度就是有好多个孩子节点，如果度为2那么就是找到树种孩子节点为2的节点"},"children":[]},{"data":{"id":"c45hxplh5jk0","created":1594643480254,"text":"度不为0的节点称为非终端节点或分支节点"},"children":[]},{"data":{"id":"c45hxppmmu00","created":1594643480505,"text":"度为0的节点称为叶子节点或终端节点"},"children":[]}]},{"data":{"id":"c45hwohz4d40","created":1594643399502,"text":"层次","expandState":"collapse"},"children":[{"data":{"id":"c45hxx5z1uo0","created":1594643496731,"text":"根为一层，根的孩子为二层"},"children":[]},{"data":{"id":"c45hxxcqeh40","created":1594643497140,"text":"树的高度自己-1 "},"children":[]},{"data":{"id":"c45hxxehl4o0","created":1594643497246,"text":"树的层次就是有多少代"},"children":[]}]},{"data":{"id":"c45hwojmwm00","created":1594643399602,"text":"森林","expandState":"collapse"},"children":[{"data":{"id":"c45hy5a3meo0","created":1594643514395,"text":"森林（Forest） 是 m (m≥0)颗 不想交的树的集合"},"children":[]}]},{"data":{"id":"c45hwolq6q80","created":1594643399729,"text":"表示方法","expandState":"collapse"},"children":[{"data":{"id":"c45hy7fqvao0","created":1594643519090,"text":"双亲表示法","expandState":"collapse"},"children":[{"data":{"id":"c45hydhnj9c0","created":1594643532266,"text":"找父节点容易，找子节点难"},"children":[]}]},{"data":{"id":"c45hy7rb0uo0","created":1594643519789,"text":"孩子表示法","expandState":"collapse"},"children":[{"data":{"id":"c45hyfr5ds80","created":1594643537194,"text":"找子节点容易，找父节点难"},"children":[]}]},{"data":{"id":"c45hy7szc3c0","created":1594643519890,"text":"孩子兄弟表示法 ","expandState":"collapse"},"children":[{"data":{"id":"c45hyi0sl6g0","created":1594643542130,"text":"找子节点容易，找父节点难"},"children":[]}]}]},{"data":{"id":"c45hwopv4z40","created":1594643399979,"text":"二叉树","expandState":"collapse"},"children":[{"data":{"id":"c45hykust3c0","created":1594643548298,"text":"定义","expandState":"collapse"},"children":[{"data":{"id":"c45hyldjue80","created":1594643549432,"text":"二叉只有2个小孩"},"children":[]}]},{"data":{"id":"c45hyqfrpjs0","created":1594643560450,"text":"斜树","expandState":"collapse"},"children":[{"data":{"id":"c45hyy77j680","created":1594643577347,"text":"斜树 就是线性结构的树"},"children":[]},{"data":{"id":"c45hz1te3tk0","created":1594643585218,"text":"所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树"},"children":[]}]},{"data":{"id":"c45hyqk65sw0","created":1594643560716,"text":"满二叉树","expandState":"collapse"},"children":[{"data":{"id":"c45hysratxk0","created":1594643565501,"text":"每个节点有2个节点"},"children":[]}]},{"data":{"id":"c45hyvdzwts0","created":1594643571227,"text":"完全二叉树","expandState":"collapse"},"children":[{"data":{"id":"c45hz5tzkdc0","created":1594643593962,"text":"如何判断是否完全二叉树","expandState":"collapse"},"children":[{"data":{"id":"c45hz7il5kw0","created":1594643597626,"text":"按层遍历二叉树,从每层从左向右遍历所有的结点"},"children":[]},{"data":{"id":"c45hz7xuf0g0","created":1594643598548,"text":"如果当前结点有右孩子,但没有左孩子,那么不是完全二叉树"},"children":[]},{"data":{"id":"c45hz7zjdls0","created":1594643598651,"text":"如果当前结点有左孩子但无右孩子,那么它之后的所有结点都必须为叶子结点，否则不是完全二叉树"},"children":[]},{"data":{"id":"c45hz8493fk0","created":1594643598936,"text":"如果当前结点有左孩子和右孩子, 继续遍历"},"children":[]}]}]}]},{"data":{"id":"c45hwordj0o0","created":1594643400070,"text":"二叉树的性质"},"children":[]},{"data":{"id":"c45hwouz2kg0","created":1594643400288,"text":"二叉树的顺序结构存储"},"children":[]},{"data":{"id":"c45hwowclrs0","created":1594643400371,"text":"二叉链表"},"children":[]},{"data":{"id":"c45hwp6owko0","created":1594643400996,"text":"二叉树的遍历 ","expandState":"collapse"},"children":[{"data":{"id":"c45hznsyvgw0","created":1594643633082,"text":"前序遍历","expandState":"collapse"},"children":[{"data":{"id":"c45hzz0mi0g0","created":1594643657490,"text":"左    右   根"},"children":[]}]},{"data":{"id":"c45hzonsobs0","created":1594643634946,"text":"中序遍历","expandState":"collapse"},"children":[{"data":{"id":"c45i01cdxhk0","created":1594643662554,"text":"右   根   左"},"children":[]}]},{"data":{"id":"c45hzosk8eg0","created":1594643635234,"text":"后序遍历","expandState":"collapse"},"children":[{"data":{"id":"c45i03pbbgo0","created":1594643667690,"text":"右   左   根"},"children":[]}]},{"data":{"id":"c45hzozykcg0","created":1594643635682,"text":"层序遍历","expandState":"collapse"},"children":[{"data":{"id":"c45hzvmklls0","created":1594643650110,"text":"逐层遍历"},"children":[]}]}]},{"data":{"id":"c45hx4uae940","created":1594643435075,"text":"二叉树转换为森林"},"children":[]},{"data":{"id":"c45hx50tgrk0","created":1594643435470,"text":"二叉树转换为树"},"children":[]},{"data":{"id":"c45hx52m9rk0","created":1594643435578,"text":"森林转化为二叉树"},"children":[]},{"data":{"id":"c45hxcj3biw0","created":1594643451812,"text":"赫夫曼树"},"children":[]},{"data":{"id":"c45hxcn4azk0","created":1594643452055,"text":"有序树"},"children":[]},{"data":{"id":"c45hxcoh62w0","created":1594643452138,"text":"无序树"},"children":[]}]},{"data":{"id":"c45hjnv35mg0","created":1594642379384,"text":"图","expandState":"collapse"},"children":[{"data":{"id":"c45i0cjnfmo0","created":1594643686938,"text":"图的特性"},"children":[]},{"data":{"id":"c45i0cszixs0","created":1594643687503,"text":"无向图"},"children":[]},{"data":{"id":"c45i0cuql1s0","created":1594643687609,"text":"有向图"},"children":[]},{"data":{"id":"c45i0d01bts0","created":1594643687929,"text":"图的权（Weight）"},"children":[]},{"data":{"id":"c45i0d1s1vs0","created":1594643688034,"text":"连通图"},"children":[]},{"data":{"id":"c45i0d3dazs0","created":1594643688131,"text":"度"},"children":[]},{"data":{"id":"c45i0d8cgk00","created":1594643688431,"text":"图的存储结构 "},"children":[]},{"data":{"id":"c45i0saklcg0","created":1594643721218,"text":"邻接矩阵"},"children":[]},{"data":{"id":"c45i0sflyxk0","created":1594643721522,"text":"带权邻接矩阵"},"children":[]},{"data":{"id":"c45i0sj2ca00","created":1594643721731,"text":"浪费的邻接矩阵 "},"children":[]},{"data":{"id":"c45i111l1fc0","created":1594643740265,"text":"邻接表"},"children":[]},{"data":{"id":"c45i116ig340","created":1594643740563,"text":"邻接表"},"children":[]},{"data":{"id":"c45i1189qjk0","created":1594643740670,"text":"逆邻接表"},"children":[]},{"data":{"id":"c45i11a14bs0","created":1594643740776,"text":"带权值邻接表"},"children":[]},{"data":{"id":"c45i11byz340","created":1594643740893,"text":"图的遍历 "},"children":[]}]},{"data":{"id":"c45hjvkwf3s0","created":1594642396182,"text":"AVL树与红黑树"},"children":[]}]},{"data":{"id":"c45gaowlow80","created":1594638855265,"text":"算法","layout":null,"expandState":"collapse"},"children":[{"data":{"id":"c45i1hygdso0","created":1594643777081,"text":"特征","expandState":"collapse"},"children":[{"data":{"id":"c45i1ylenk00","created":1594643813298,"text":"有穷性"},"children":[]},{"data":{"id":"c45i1yvo4a00","created":1594643813918,"text":"确切性"},"children":[]},{"data":{"id":"c45i1yxlx3k0","created":1594643814036,"text":"输入项"},"children":[]},{"data":{"id":"c45i1yzj7s00","created":1594643814152,"text":"输出项"},"children":[]},{"data":{"id":"c45i1z4yge00","created":1594643814480,"text":"可行性"},"children":[]}]},{"data":{"id":"c45i1iayv1c0","created":1594643777838,"text":"算法运算要素","expandState":"collapse"},"children":[{"data":{"id":"c45i2b0cfkg0","created":1594643840322,"text":"算术运算：加减乘除等运算"},"children":[]},{"data":{"id":"c45i2bktglc0","created":1594643841560,"text":"逻辑运算：或、且、非等运算"},"children":[]},{"data":{"id":"c45i2bml8080","created":1594643841667,"text":"关系运算：大于、小于、等于、不等于等运算"},"children":[]},{"data":{"id":"c45i2bowlcg0","created":1594643841807,"text":"数据传输：输入、输出、赋值等运算"},"children":[]}]},{"data":{"id":"c45i1icu44g0","created":1594643777951,"text":"算法优劣评定","expandState":"collapse"},"children":[{"data":{"id":"c45i2k58db40","created":1594643860209,"text":"时间复杂度"},"children":[]},{"data":{"id":"c45i2kgb5ow0","created":1594643860879,"text":"空间复杂度"},"children":[]},{"data":{"id":"c45i2kibedc0","created":1594643861000,"text":"正确性"},"children":[]},{"data":{"id":"c45i2kk3bns0","created":1594643861108,"text":"可读性"},"children":[]},{"data":{"id":"c45i2kmlj140","created":1594643861259,"text":"健壮性 "},"children":[]}]},{"data":{"id":"c45i1if2tmw0","created":1594643778087,"text":"必备数学知识","expandState":"collapse"},"children":[{"data":{"id":"c45i2ukg3d40","created":1594643882897,"text":"Mod运算","layout_right_offset":{"x":1,"y":19}},"children":[{"data":{"id":"c45i2xhrrqw0","created":1594643889265,"text":"如果M>N,则M%N<M/2"},"children":[]}]},{"data":{"id":"c45i2utu27s0","created":1594643883464,"text":"幂运算","layout_right_offset":{"x":2,"y":44}},"children":[{"data":{"id":"c45i36n2wog0","created":1594643909177,"text":"XA*XB = X(A+B)\nX1/2 = 2√x\nXA/B = B√xA"},"children":[]}]},{"data":{"id":"c45i2uvqeqg0","created":1594643883579,"text":"对数运算","layout_right_offset":{"x":-2,"y":53}},"children":[{"data":{"id":"c45i34crtyo0","created":1594643904201,"text":"NlogA = logAN\nLog(A*B) = LogA+LogB"},"children":[]}]}]},{"data":{"id":"c45i1ijtt4w0","created":1594643778374,"text":"时间复杂度","layout_right_offset":{"x":9,"y":44},"expandState":"collapse"},"children":[{"data":{"id":"c45i3hv51lk0","created":1594643933609,"text":"O（N^3）"},"children":[]},{"data":{"id":"c45i3kf827k0","created":1594643939177,"text":"O（N^2）"},"children":[]},{"data":{"id":"c45i3kkotuw0","created":1594643939508,"text":"O  (N)"},"children":[]},{"data":{"id":"c45i3kmlof40","created":1594643939623,"text":"O（NLogN）"},"children":[]},{"data":{"id":"c45i3kp0hiw0","created":1594643939769,"text":"O（LogN）"},"children":[]},{"data":{"id":"c45i3kuog140","created":1594643940112,"text":"O（1） "},"children":[]}]},{"data":{"id":"c45i1ilkkw00","created":1594643778479,"text":"算法分析方法","layout_right_offset":{"x":2,"y":-40}},"children":[]},{"data":{"id":"c45i1iqejvk0","created":1594643778771,"text":"八大内部排序技术"},"children":[]}]},{"data":{"id":"c45gaspo4ag0","created":1594638863553,"text":"性能优化","layout":null,"expandState":"collapse"},"children":[{"data":{"id":"c45i3wrnys00","created":1594643966051,"text":"APP启动优化"},"children":[]},{"data":{"id":"c45i3wtqrbc0","created":1594643966177,"text":"UI绘制优化"},"children":[]},{"data":{"id":"c45i3wvrehs0","created":1594643966299,"text":"内存优化"},"children":[]},{"data":{"id":"c45i3wyoj340","created":1594643966475,"text":"图片压缩初体验"},"children":[]},{"data":{"id":"c45i3x46o1c0","created":1594643966808,"text":"电量优化"},"children":[]},{"data":{"id":"c45i4x9kw800","created":1594644045498,"text":"APK加固"},"children":[]},{"data":{"id":"c45i4xpmmmw0","created":1594644046469,"text":"Protobuf"},"children":[]},{"data":{"id":"c45i4xroubs0","created":1594644046593,"text":"进程保活"},"children":[]},{"data":{"id":"c45i4xv5k1k0","created":1594644046803,"text":"7z压缩"},"children":[]},{"data":{"id":"c45i4xy0fhk0","created":1594644046976,"text":"长图优化与电量优化"},"children":[]},{"data":{"id":"c45i4y35g8o0","created":1594644047286,"text":"Tinker原理分析（So修复与资源替换）与Apk极限瘦身"},"children":[]},{"data":{"id":"c45i4y52n2o0","created":1594644047403,"text":"APK极限压缩与webp应用"},"children":[]}]},{"data":{"id":"c45gb66knbk0","created":1594638892873,"text":"移动架构","expandState":"collapse"},"children":[{"data":{"id":"c45i5njykgw0","created":1594644102722,"text":"移动架构师第一站UML建模"},"children":[]},{"data":{"id":"c45i5nsguqo0","created":1594644103237,"text":"Android消息机制"},"children":[]},{"data":{"id":"c45i5nuh6wo0","created":1594644103358,"text":"Android Binder机制"},"children":[]},{"data":{"id":"c45i5nwk6i80","created":1594644103484,"text":"Android AMS服务"},"children":[]},{"data":{"id":"c45i5nzafy00","created":1594644103649,"text":"Android PKMS服务"},"children":[]},{"data":{"id":"c45i5o4nusg0","created":1594644103974,"text":"Android AOP架构设计"},"children":[]},{"data":{"id":"c45i5o6m96w0","created":1594644104092,"text":"EventBus 架构设计"},"children":[]},{"data":{"id":"c45i5o8p3yw0","created":1594644104218,"text":"跨进程架构Hermes分析"},"children":[]},{"data":{"id":"c45i5oarov40","created":1594644104343,"text":"动态式换肤框架分析"},"children":[]},{"data":{"id":"c45i5ocuk0g0","created":1594644104469,"text":"数据库框架设计"},"children":[]},{"data":{"id":"c45i5oewj400","created":1594644104593,"text":"组件化"},"children":[]},{"data":{"id":"c45i5ok8o5k0","created":1594644104916,"text":"Glide框架设计 "},"children":[]},{"data":{"id":"c45i6frcx8w0","created":1594644164120,"text":"插件化架构设计"},"children":[]},{"data":{"id":"c45i6fu1x3c0","created":1594644164283,"text":"RXJava2响应式编程框架设计"},"children":[]},{"data":{"id":"c45i6fwdxts0","created":1594644164424,"text":"Okhttp框架设计"},"children":[]},{"data":{"id":"c45i6fyh92o0","created":1594644164550,"text":"IOC注入框架设计"},"children":[]}]},{"data":{"id":"c45hdzxzlkg0","created":1594641935495,"text":"高级UI","expandState":"collapse"},"children":[{"data":{"id":"c45i6w9th5k0","created":1594644200064,"text":"UI绘制流程 "},"children":[]},{"data":{"id":"c45i6wjrrbc0","created":1594644200666,"text":"UI绘制流程(测量布局)"},"children":[]},{"data":{"id":"c45i6wlyh4w0","created":1594644200798,"text":"Paint-滤镜,XFERMODE"},"children":[]},{"data":{"id":"c45i6wnzhxc0","created":1594644200921,"text":"Canvas"},"children":[]},{"data":{"id":"c45i6wqh23c0","created":1594644201071,"text":"Paint-gradient"},"children":[]},{"data":{"id":"c45i6wtirds0","created":1594644201256,"text":"贝塞尔曲线"},"children":[{"data":{"id":"c45i7ccnrew0","created":1594644235065,"text":"一阶贝塞尔曲线的核心目的其实就只是由两点控制的一条直线"},"children":[]},{"data":{"id":"c45i7ck32480","created":1594644235514,"text":"二阶贝塞尔曲线是由一个控制点去控制一条的曲线,而曲线的运动是由两个直线所控制"},"children":[]}]},{"data":{"id":"c45i6wx9kog0","created":1594644201482,"text":"PathMeasure"},"children":[]},{"data":{"id":"c45i6wzc09s0","created":1594644201607,"text":"屏幕适配"},"children":[]},{"data":{"id":"c45i6x1lho80","created":1594644201744,"text":"事件分发"},"children":[]},{"data":{"id":"c45i6x3t1f40","created":1594644201878,"text":"属性动画"},"children":[]},{"data":{"id":"c45i6x9rzds0","created":1594644202239,"text":"自定义动画框架 "},"children":[]},{"data":{"id":"c45i7oc3o4w0","created":1594644261152,"text":"meterial design"},"children":[]},{"data":{"id":"c45i7oi9etk0","created":1594644261525,"text":"RecycleView"},"children":[]},{"data":{"id":"c45i7okdfso0","created":1594644261652,"text":"CoordinatorLayout原理应用"},"children":[]},{"data":{"id":"c45i7omh68w0","created":1594644261780,"text":"沉浸式"},"children":[]},{"data":{"id":"c45i7oopffc0","created":1594644261914,"text":"自定义控件 "},"children":[]},{"data":{"id":"c45i80lc09s0","created":1594644287832,"text":"SVG矢量图形打造不规则的自定义控件"},"children":[]},{"data":{"id":"c45i80o0dnk0","created":1594644287994,"text":"VLayout使用与原理详解 "},"children":[]}]},{"data":{"id":"c45he5pfvq80","created":1594641948040,"text":"疑难杂症","expandState":"collapse"},"children":[{"data":{"id":"c45i88si5sg0","created":1594644305680,"text":"Java中final、finally、finalize的区别","expandState":"collapse"},"children":[{"data":{"id":"c45i99wo1k00","created":1594644386472,"text":"final","expandState":"collapse"},"children":[{"data":{"id":"c45i9a39qqw0","created":1594644386872,"text":"用于声明属性，方法和类，分别表示属性不可交变，方法不可覆盖，类不可继承。"},"children":[]}]},{"data":{"id":"c45i9bx5qzk0","created":1594644390856,"text":"finally","expandState":"collapse"},"children":[{"data":{"id":"c45i9ledqqg0","created":1594644411488,"text":"是异常处理语句结构的一部分，表示总是执行。"},"children":[]}]},{"data":{"id":"c45i9c3kzu80","created":1594644391244,"text":"finalize","expandState":"collapse"},"children":[{"data":{"id":"c45i9pn6sew0","created":1594644420728,"text":"是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，供垃圾收集时的其他资源回收，例如关闭文件等。"},"children":[]}]}]},{"data":{"id":"c45i8942q7s0","created":1594644306379,"text":"内存泄漏","expandState":"collapse"},"children":[{"data":{"id":"c45i9w80n400","created":1594644435048,"text":"定义","expandState":"collapse"},"children":[{"data":{"id":"c45iaa7kank0","created":1594644465495,"text":"内存不在GC掌控之内"},"children":[]}]},{"data":{"id":"c45i9wya4p40","created":1594644436636,"text":"内存分配的几种策略","expandState":"collapse"},"children":[{"data":{"id":"c45iadap8b40","created":1594644472215,"text":"静态的","expandState":"collapse"},"children":[{"data":{"id":"c45ianl55wg0","created":1594644494615,"text":"静态的存储区：内存在程序编译的时候就已经分配好，这块的内存在程序整个运行期间都一直存在。它主要存放静态数据、全局的static数据和一些常量"},"children":[]}]},{"data":{"id":"c45iadjpnq80","created":1594644472760,"text":"栈式的","expandState":"collapse"},"children":[{"data":{"id":"c45iapmpewg0","created":1594644499063,"text":"在执行函数(方法)时，函数一些内部变量的存储都可以放在栈上面创建，函数执行结束的时候这些存储单元就会自动被释放掉"},"children":[]},{"data":{"id":"c45iapx2j3k0","created":1594644499689,"text":"栈内存包括分配的运算速度很快"},"children":[]},{"data":{"id":"c45iapzcxls0","created":1594644499828,"text":"内置在处理器的里面容量有限"},"children":[]}]},{"data":{"id":"c45iadm25ug0","created":1594644472902,"text":"堆式的","expandState":"collapse"},"children":[{"data":{"id":"c45iazkzmgw0","created":1594644520727,"text":"也叫做动态内存分配"},"children":[]},{"data":{"id":"c45ib0vmfw80","created":1594644523547,"text":"在C/C++可能需要自己负责释放（java里面直接依赖GC机制）"},"children":[]}]},{"data":{"id":"c45iadoc69s0","created":1594644473040,"text":"区别","expandState":"collapse"},"children":[{"data":{"id":"c45ib53z1k80","created":1594644532759,"text":"堆是不连续的内存区域，堆空间比较灵活也特别大。栈式一块连续的内存区域，大小是有操作系统觉决定的"},"children":[]}]}]},{"data":{"id":"c45i9x0p8gw0","created":1594644436782,"text":"引用机制","expandState":"collapse"},"children":[{"data":{"id":"c45ib9qotoo0","created":1594644542839,"text":"StrongReference 强引用","expandState":"collapse"},"children":[{"data":{"id":"c45ibij0xq00","created":1594644561967,"text":"回收时机：从不回收 \n使用：对象的一般保存  \n生命周期：JVM停止的时候才会终止"},"children":[]}]},{"data":{"id":"c45iba6ce8w0","created":1594644543786,"text":"SoftReference 软引用","expandState":"collapse"},"children":[{"data":{"id":"c45ibl0v6a00","created":1594644567399,"text":"回收时机：当内存不足的时候；\n使用：SoftReference<String>结合ReferenceQueue构造有效期短；\n生命周期：内存不足时终止"},"children":[]}]},{"data":{"id":"c45iba8m7i00","created":1594644543923,"text":"WeakReference 弱引用","expandState":"collapse"},"children":[{"data":{"id":"c45ibns82og0","created":1594644573407,"text":"回收时机：在垃圾回收的时候；\n使用：同软引用； \n生命周期：GC后终止"},"children":[]}]},{"data":{"id":"c45ibab0i200","created":1594644544068,"text":"PhatomReference 虚引用","expandState":"collapse"},"children":[{"data":{"id":"c45ibq0tl1s0","created":1594644578280,"text":"回收时机：在垃圾回收的时候；\n使用：合ReferenceQueue来跟踪对象呗垃圾回收期回收的活动； 生命周期:GC后终止"},"children":[]}]}]},{"data":{"id":"c45i9x309800","created":1594644436922,"text":"注意","background":"#ff0000","expandState":"collapse"},"children":[{"data":{"id":"c45ibtoavp40","created":1594644586231,"text":"尽量使用软引用和弱引用。软引用比LRU算法更加任性"},"children":[]}]}]},{"data":{"id":"c45i89696xs0","created":1594644306511,"text":"CountDownLatch和CyclicBarrier区别","expandState":"collapse"},"children":[{"data":{"id":"c45ic5150m00","created":1594644610951,"text":"CountDownLatch","expandState":"collapse"},"children":[{"data":{"id":"c45ic93bo280","created":1594644619791,"text":"是一个计数器，线程完成一个记录一个，计数器递减，只能只用一次"},"children":[]}]},{"data":{"id":"c45ic5c1h5k0","created":1594644611611,"text":"CyclicBarrier","expandState":"collapse"},"children":[{"data":{"id":"c45icbk3qio0","created":1594644625159,"text":"的计数器更像一个阀门，需要所有线程都到达，然后继续执行，计数器递增，提供reset功能，可以多次使用"},"children":[]}]}]},{"data":{"id":"c45i898fp880","created":1594644306643,"text":"HasMap","expandState":"collapse"},"children":[{"data":{"id":"c45icjnkwew0","created":1594644642783,"text":"定义","expandState":"collapse"},"children":[{"data":{"id":"c45idv586ko0","created":1594644746159,"text":"HashMap本质是一个一定长度的数组，数组中存放的是链表"},"children":[]}]},{"data":{"id":"c45icjz1lbc0","created":1594644643476,"text":"hashCode","expandState":"collapse"},"children":[{"data":{"id":"c45idyr4ma80","created":1594644754014,"text":"前提是对象上 equals 比较中所用的信息没有被修改"},"children":[]},{"data":{"id":"c45idz2tqqo0","created":1594644754721,"text":"同一对象上多次调用 hashCode 方法时，必须一致地返回相同的整数"},"children":[]},{"data":{"id":"c45idz64hnc0","created":1594644754920,"text":"如果根据 equals(Object) 方法，两个对象是相等的，那么在两个对象中的每个对象上调用 hashCode 方法都必须生成相同的整数结果 "},"children":[]}]},{"data":{"id":"c45ick1ednc0","created":1594644643619,"text":"equals","expandState":"collapse"},"children":[{"data":{"id":"c45ie5s959c0","created":1594644769319,"text":"自反性：对于任何非空引用值 x，x.equals(x) 都应返回 true"},"children":[]},{"data":{"id":"c45ie61dc200","created":1594644769870,"text":"对称性：对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 才应返回 true"},"children":[]},{"data":{"id":"c45ie63o2y00","created":1594644770009,"text":"传递性：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true，并且 y.equals(z) 返回 true，那么 x.equals(z) 应返回 true"},"children":[]},{"data":{"id":"c45ie66cvd40","created":1594644770172,"text":"一致性：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false，前提是对象上 equals 比较中所用的信息没有被修改。 对于任何非空引用值 x，x.equals(null) 都应返回 false "},"children":[]}]},{"data":{"id":"c45ick3s3n40","created":1594644643763,"text":"HashMap的特性","expandState":"collapse"},"children":[{"data":{"id":"c45ief33q4g0","created":1594644789566,"text":"快速存取，允许为null。key值不可重复，若key值重复则覆盖"},"children":[]},{"data":{"id":"c45iefbxtrs0","created":1594644790101,"text":"非同步，线程不安全"},"children":[]},{"data":{"id":"c45iefeclvs0","created":1594644790246,"text":"底层是hash表，不保证有序(比如插入的顺序)"},"children":[]}]},{"data":{"id":"c45ick6asf40","created":1594644643915,"text":"HashMap的底层原理是什么","expandState":"collapse"},"children":[{"data":{"id":"c45iemihgo00","created":1594644805734,"text":"底层是hash表，不保证有序(比如插入的顺序)"},"children":[]},{"data":{"id":"c45iemqrcv40","created":1594644806234,"text":"put()方法传递键和值时，先对键做一个hashCode()的计算来得到它在bucket数组中的位置来存储Entry对象"},"children":[]},{"data":{"id":"c45iemt9emw0","created":1594644806385,"text":"get()获取到bucket的位置，再通过键对象的equals()方法找到正确的键值对 "},"children":[]}]},{"data":{"id":"c45ickayo7s0","created":1594644644197,"text":"HashMap中put是如何实现的","expandState":"collapse"},"children":[{"data":{"id":"c45ieuin5jk0","created":1594644823158,"text":"计算关于key的hashcode值（与Key.hashCode的高16位做异或运算）"},"children":[]},{"data":{"id":"c45ieuv4q000","created":1594644823913,"text":"如果散列表为空时，调用resize()初始化散列表"},"children":[]},{"data":{"id":"c45ieuxq1e80","created":1594644824070,"text":"如果没有发生碰撞，直接添加元素到散列表中去"},"children":[]},{"data":{"id":"c45iev0f6bc0","created":1594644824233,"text":"如果发生了碰撞(hashCode值相同) ","expandState":"collapse"},"children":[{"data":{"id":"c45if2fdk200","created":1594644840374,"text":"若key地址相同或者equals后内容相同，则替换旧值"},"children":[]},{"data":{"id":"c45if7eduow0","created":1594644851198,"text":"如果是红黑树结构，就调用树的插入方法"},"children":[]},{"data":{"id":"c45if7hh9ig0","created":1594644851385,"text":"链表结构，循环遍历直到链表中某个节点为空，尾插法进行插入，插入之后判断链表个数是否到达变成红黑树的阙值8； "},"children":[]},{"data":{"id":"c45if7zoq2g0","created":1594644852486,"text":"也可以遍历到有节点与插入元素的哈希值和内容相同，进行覆盖"},"children":[]}]},{"data":{"id":"c45if43kr140","created":1594644844014,"text":"如果桶满了大于阀值，则resize进行扩容"},"children":[]}]},{"data":{"id":"c45ickddgb40","created":1594644644343,"text":"扩容resize()又是如何实现的","expandState":"collapse"},"children":[{"data":{"id":"c45ifhqoq1s0","created":1594644873710,"text":"扩容需要重新分配一个新数组，新数组是老数组的2倍长，然后遍历整个老结构，把所有的元素挨个重新hash分配到新结构中去。"},"children":[]}]},{"data":{"id":"c45ickfwy2o0","created":1594644644497,"text":"HashMap中get是如何实现的","expandState":"collapse"},"children":[{"data":{"id":"c45ifk9tlaw0","created":1594644879222,"text":"对Key进行HashCode与运算计算下标获取bucket位置"},"children":[]},{"data":{"id":"c45ifkiyxgw0","created":1594644879774,"text":"如果在桶的首位上就可以找到就直接返回，否则在树中找或者链表中遍历找，如果有hash冲突，则利用equals方法去遍历链表查找节点"},"children":[]}]},{"data":{"id":"c45ickichgg0","created":1594644644644,"text":"Hash函数是怎么实现的","expandState":"collapse"},"children":[{"data":{"id":"c45ifpq14qo0","created":1594644891085,"text":"对key的hashCode做hash操作，与高16位做异或运算"},"children":[]},{"data":{"id":"c45ifpyjas00","created":1594644891599,"text":"Hsatable平方取中法，除留余数法，伪随机数法"},"children":[]}]},{"data":{"id":"c45ickl2e1s0","created":1594644644808,"text":"为什么不直接将key作为哈希值而是与高16位做异或运算","expandState":"collapse"},"children":[{"data":{"id":"c45ig20h70o0","created":1594644917838,"text":"减少了哈希碰撞的次数"},"children":[]},{"data":{"id":"c45ig3655i00","created":1594644920357,"text":"因为数组位置的确定用的是与运算，仅仅最后四位有效"},"children":[]}]},{"data":{"id":"c45icknhgkw0","created":1594644644954,"text":"两个对象的hashCode相等时会怎么样","expandState":"collapse"},"children":[{"data":{"id":"c45ig7kwmg00","created":1594644929957,"text":"会产生哈希碰撞，若key值相同则替换旧值，不然链接到链表后面，链表长度超过阙值8就转为红黑树存储"},"children":[]}]},{"data":{"id":"c45ickq3ckw0","created":1594644645112,"text":"两个键的hashcode相同，你如何获取值对象 ","expandState":"collapse"},"children":[{"data":{"id":"c45igc2z8mg0","created":1594644939757,"text":"HashCode相同，通过equals比较内容获取值对象"},"children":[]}]},{"data":{"id":"c45id6inkso0","created":1594644692551,"text":"如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办","expandState":"collapse"},"children":[{"data":{"id":"c45igf3r9yo0","created":1594644946334,"text":"超过阙值会进行扩容操作，概括的讲就是扩容后的数组大小是原数组的2倍，将原来的元素重新hashing放入到新的散列表中去"},"children":[]}]},{"data":{"id":"c45id6m2pa80","created":1594644692758,"text":"HashMap的参数loadFactor，它的作用是什么","expandState":"collapse"},"children":[{"data":{"id":"c45igkhc7880","created":1594644958039,"text":"默认loadFactor等于0.75，当HashMap里面容纳的元素已经达到HashMap数组长度的75%时，表示HashMap太挤了，需要扩容，在HashMap的构造器中可以定制loadFactor"},"children":[]}]},{"data":{"id":"c45id6sroiw0","created":1594644693163,"text":"HashMap的缺点(为什么引入红黑树？)","expandState":"collapse"},"children":[{"data":{"id":"c45igom15z40","created":1594644967030,"text":"JDK 1.8 以前 HashMap 的实现是 数组+链表，即使哈希函数取得再好，也很难达到元素百分百均匀分布"},"children":[]},{"data":{"id":"c45igp5qfwg0","created":1594644968222,"text":"当 HashMap 中有大量的元素都存放到同一个桶中时，这个桶下有一条长长的链表，这个时候 HashMap 就相当于一个单链表，假如单链表有 n 个元素，遍历的时间复杂度就是 O(n)，完全失去了它的优势。针对这种情况，JDK 1.8 中引入了 红黑树（查找时间复杂度为 O(logn)）来优化这个问题 "},"children":[]}]},{"data":{"id":"c45id6v662w0","created":1594644693308,"text":"HashMap时一般使用什么类型的元素作为Key","expandState":"collapse"},"children":[{"data":{"id":"c45ih2l6nyo0","created":1594644997454,"text":"选择Integer，String这种不可变的类型，像对String的一切操作都是新建一个String对象，对新的对象进行拼接分割等，这些类已经很规范的覆写了hashCode()以及equals()方法。作为不可变类天生是线程安全的"},"children":[]}]},{"data":{"id":"c45id6xqxy80","created":1594644693464,"text":"Hashmap的底层扩容是怎么实现的","expandState":"collapse"},"children":[{"data":{"id":"c45ih5q69ww0","created":1594645004286,"text":"原因","expandState":"collapse"},"children":[{"data":{"id":"c45ihac80bk0","created":1594645014326,"text":"扩容因子 0.75","expandState":"collapse"},"children":[{"data":{"id":"c45ihchvl7k0","created":1594645019022,"text":"比如0.5，那么当存放的元素超过一半时就进行扩容，会造成资源的浪费"},"children":[]},{"data":{"id":"c45ihcsxmgw0","created":1594645019690,"text":"比如1，那么当元素满的时候才进行扩容，会使get,put操作的碰撞几率增加"},"children":[]}]}]},{"data":{"id":"c45ih626l9k0","created":1594645005012,"text":"扩容","expandState":"collapse"},"children":[{"data":{"id":"c45ihjhwoe00","created":1594645034261,"text":"DEFAULT_INITIAL_CAPACITY = 1 << 4;     // HashMap初始容量大小(16)"},"children":[]},{"data":{"id":"c45ihjsotp40","created":1594645034913,"text":"那么当HashMap中元素个数超过16*0.75=12（这个值就是代码中的threshold值，也叫做临界值）"},"children":[]},{"data":{"id":"c45ihrbplaw0","created":1594645051301,"text":"HashMap不是无限扩容的  1 << 30;               // HashMap最大容量"},"children":[]}]}]},{"data":{"id":"c45id70652o0","created":1594644693611,"text":"Hashmap为什么大小是2的幂次","expandState":"collapse"},"children":[{"data":{"id":"c45ihyrmzp40","created":1594645067501,"text":"如果map长度为2的幂次，那长度-1的二进制一定为11111...这种形式，进行与运算就看元素的hashcode"},"children":[]},{"data":{"id":"c45ihz2h8uo0","created":1594645068157,"text":"但是如果map的长度不是2的幂次，比如为15，那长度-1就是14，二进制为1110，key的has值与1110,算不出来1,3,5,7,9...."},"children":[]},{"data":{"id":"c45ihz5adnk0","created":1594645068327,"text":"空间浪费map长度除2。也增加了添加元素是发生碰撞的机会。减慢了查询效率 "},"children":[]}]},{"data":{"id":"c45id72oxd40","created":1594644693763,"text":"什么是负载因子 ","expandState":"collapse"},"children":[{"data":{"id":"c45iirl1dyo0","created":1594645130229,"text":"0.75"},"children":[]},{"data":{"id":"c45iiwqspr40","created":1594645141461,"text":"那么当HashMap中元素个数超过16*0.75=12（这个值就是代码中的threshold值，也叫做临界值）"},"children":[]}]},{"data":{"id":"c45idkqt5000","created":1594644723519,"text":"HashMap和HashTable有什么区别","expandState":"collapse"},"children":[{"data":{"id":"c45ij0b56ps0","created":1594645149222,"text":"父类不同","expandState":"collapse"},"children":[{"data":{"id":"c45ijgp7rrk0","created":1594645184901,"text":"也可能是Hashtable开始设计的时候没有遵循驼峰命名法"},"children":[]},{"data":{"id":"c45ijh35f280","created":1594645185744,"text":"Hashtable是线程安全的，效率比较低"},"children":[]},{"data":{"id":"c45ijh63tsw0","created":1594645185922,"text":"HashMap是继承自AbstractMap类而HashTable是继承自Dictionary（已被废弃，详情看源代码）"},"children":[]},{"data":{"id":"c45ijh91nf40","created":1594645186100,"text":"Hashtable比HashMap多提供了elments()和contains()两个方法。 "},"children":[]}]},{"data":{"id":"c45ij0nlwew0","created":1594645149975,"text":"Null值问题","expandState":"collapse"},"children":[{"data":{"id":"c45ijqq1a3k0","created":1594645206718,"text":"Hashtable既不支持Null key也不支持Null value"},"children":[]},{"data":{"id":"c45ijr1pvs00","created":1594645207425,"text":"HashMap中，Null可以作为键，这样的键只有一个"},"children":[]}]},{"data":{"id":"c45ij0qf3080","created":1594645150145,"text":"线程安全性","expandState":"collapse"},"children":[{"data":{"id":"c45imw0pvvk0","created":1594645453341,"text":"Hashtable是线程安全的"},"children":[]},{"data":{"id":"c45imwboxgw0","created":1594645454004,"text":"HashMap不是线程安全的"},"children":[]}]},{"data":{"id":"c45ij0tl6940","created":1594645150337,"text":"初始容量不同","expandState":"collapse"},"children":[{"data":{"id":"c45in3fowiw0","created":1594645469484,"text":"Hashtable的初始长度是11，之后每次扩充容量变为之前的2n+1（n为上一次的长度）"},"children":[]},{"data":{"id":"c45in3ot6fc0","created":1594645470035,"text":"HashMap的初始长度为16，之后每次扩充变为原来的两倍"},"children":[]}]},{"data":{"id":"c45ij0xg1d40","created":1594645150570,"text":"计算哈希值的方法不同","expandState":"collapse"},"children":[{"data":{"id":"c45in86dws00","created":1594645479805,"text":"Hashtable直接使用对象的hashCode （使用除留余数发来获得最终的位置）非常耗费时间的。效率很低"},"children":[]},{"data":{"id":"c45in8klty00","created":1594645480665,"text":"HashMap为了提高计算效率，（做位运算。位运算比除法的效率要高）将哈希表的大小固定为了2的幂"},"children":[]}]}]},{"data":{"id":"c45idktgztc0","created":1594644723680,"text":"Hash碰撞是什么","expandState":"collapse"},"children":[{"data":{"id":"c45injptkkg0","created":1594645504925,"text":"定义","expandState":"collapse"},"children":[{"data":{"id":"c45inom21800","created":1594645515581,"text":"由于hash算法有可能使不同的元素计算出同一个hashcode，当多个不同key值的hashcode相同并要存入hashmap时，称为hashmap的碰撞。"},"children":[]}]},{"data":{"id":"c45injz77680","created":1594645505492,"text":"解决","expandState":"collapse"},"children":[{"data":{"id":"c45inr2p0ew0","created":1594645520940,"text":"hashmap使用链表解决冲突， 把HashCode相同的Value连成链表. get的时候根据Key找，如果获得的是链表说明是冲突的，此时还需要检测Key是否相同"},"children":[]},{"data":{"id":"c45inrdrbzc0","created":1594645521610,"text":"HashMap通过键的hashCode来快速的存取元素"},"children":[]},{"data":{"id":"c45inx1exl40","created":1594645533924,"text":"当不同的对象发生碰撞时，HashMap通过单链表来解决，将新元素加入链表表头，通过next指向原有的元素。单链表在Java中的实现就是对象的引用(复合)"},"children":[]}]}]},{"data":{"id":"c45idkw3c6o0","created":1594644723839,"text":"Hashmap为什么说是线程不安全的","expandState":"collapse"},"children":[{"data":{"id":"c45io16sdpk0","created":1594645542956,"text":"扩容造成的"},"children":[]},{"data":{"id":"c45io1lmqxc0","created":1594645543853,"text":"容量（由负载因子决定）的范围就会触发扩容操作，扩容后重新将原数组的内容重新hash到新的扩容数组中"},"children":[]},{"data":{"id":"c45io22d0a00","created":1594645544865,"text":"多线程的环境下，同时put操作，如果hash值相同，可能出现同时在同一数组下用链表表示，造成闭环，导致在get时会出现死循环"},"children":[]}]}]},{"data":{"id":"c45i89ap7ag0","created":1594644306780,"text":"HashMap和ArrayMap各自的优势","expandState":"collapse"},"children":[{"data":{"id":"c45iodjkzhs0","created":1594645569851,"text":"查找效率"},"children":[{"data":{"id":"c45iopk8c6g0","created":1594645596011,"text":"HashMap因为其根据hashcode的值直接算出index,所以其查找效率是随着数组长度增大而增加的。\nArrayMap使用的是二分法查找,所以当数组长度每增加一倍时,就需要多进行一次判断,效率下降。\n所以对于Map数量比较大的情况下,推荐使用"},"children":[]}]},{"data":{"id":"c45ioducd8o0","created":1594645570503,"text":"扩容数量"},"children":[{"data":{"id":"c45iosfpluo0","created":1594645602268,"text":"HashMap初始值16个长度,每次扩容的时候,直接申请双倍的数组空间。\nArrayMap每次扩容的时候,如果size长度大于8时申请size*1.5个长度,大于4小于8时申请8个,小于4时申请4个。\n这样比较ArrayMap其实是申请了更少的内存空间,但是扩容的频率会更高。因此,如果当数据量比较大的时候,还是使用HashMap更合适,因为其扩容的次数要比ArrayMap少很多。"},"children":[]}]},{"data":{"id":"c45iodxjajs0","created":1594645570695,"text":"扩容效率"},"children":[{"data":{"id":"c45iouv0fu80","created":1594645607547,"text":"HashMap每次扩容的时候时重新计算每个数组成员的位置,然后放到新的位置。\nArrayMap则是直接使用System.arraycopy。\n所以效率上肯定是ArrayMap更占优势。\n这里需要说明一下,网上有一种传闻说因为ArrayMap使用System.arraycopy更省内存空间,这一点我真的没有看出来。arraycopy也是把老的数组的对象一个一个的赋给新的数组。当然效率上肯定arraycopy更高,因为是直接调用的c层的代码。"},"children":[]}]},{"data":{"id":"c45ioe0phyw0","created":1594645570886,"text":"内存耗费"},"children":[{"data":{"id":"c45ioxdnr6g0","created":1594645613028,"text":"以ArrayMap采用了一种独特的方式,能够重复的利用因为数据扩容而遗留下来的数组空间,方便下一个ArrayMap的使用。而HashMap没有这种设计。\n由于ArrayMap只缓存了长度是4和8的时候,所以如果频繁的使用到Map,而且数据量都比较小的时候,ArrayMap无疑是相当的节省内存的。"},"children":[]}]},{"data":{"id":"c45ioe3q77s0","created":1594645571069,"text":"注意"},"children":[{"data":{"id":"c45ip0093880","created":1594645618748,"text":"数据量比较小,并且需要频繁的使用Map存储数据的时候,推荐使用ArrayMap。而数据量比较大的时候,则推荐使用HashMap"},"children":[]}]}]},{"data":{"id":"c45i89cwmsw0","created":1594644306913,"text":"实现线程同步的几种方式","expandState":"collapse"},"children":[{"data":{"id":"c45ip6euv140","created":1594645632692,"text":"定义","expandState":"collapse"},"children":[{"data":{"id":"c45ip9bd8u00","created":1594645639011,"text":"在多线程中线程的执行顺序是依靠哪个线程先获得到CUP的执行权谁就先执行，虽然说可以通过线程的优先权进行设置，但是他只是获取CUP执行权的概率高点，但是也不一定必须先执行"},"children":[]}]},{"data":{"id":"c45ipe5d9e00","created":1594645649532,"text":"通过Object的wait和notify"},"children":[]},{"data":{"id":"c45ipejb41k0","created":1594645650375,"text":"通过Condition的awiat和signal"},"children":[]},{"data":{"id":"c45ipem5gs80","created":1594645650547,"text":"通过一个阻塞队列"},"children":[]},{"data":{"id":"c45ipep8r3c0","created":1594645650734,"text":"通过两个阻塞队列"},"children":[]},{"data":{"id":"c45iplseuf40","created":1594645666163,"text":"通过SynchronousQueue "},"children":[]},{"data":{"id":"c45ipm340pc0","created":1594645666810,"text":"通过线程池的Callback回调"},"children":[]},{"data":{"id":"c45ipm62hs00","created":1594645666989,"text":"通过同步辅助类CountDownLatch "},"children":[]},{"data":{"id":"c45ips052k80","created":1594645679691,"text":"通过同步辅助类CyclicBarrier"},"children":[]},{"data":{"id":"c45ipu7nl2w0","created":1594645684499,"text":"CyclicBarrier 与 CountDownLatch 区别","expandState":"collapse"},"children":[{"data":{"id":"c45ipwjso8g0","created":1594645689587,"text":"CountDownLatch 是一次性的，CyclicBarrier 是可循环利用的"},"children":[]},{"data":{"id":"c45ipwvtu4o0","created":1594645690314,"text":"CountDownLatch 参与的线程的职责是不一样的，有的在倒计时，有的在等待倒计时结束"},"children":[]},{"data":{"id":"c45ipwyx4vk0","created":1594645690501,"text":"CyclicBarrier 参与的线程职责是一样的 "},"children":[]}]}]},{"data":{"id":"c45i89f7xxc0","created":1594644307053,"text":"EventBus实现原理"},"children":[]},{"data":{"id":"c45i89hwd6g0","created":1594644307215,"text":"RxJava实现原理"},"children":[]},{"data":{"id":"c45i89kp5p40","created":1594644307385,"text":"ButterKnife 实现原理"},"children":[]},{"data":{"id":"c45i89qm0uw0","created":1594644307742,"text":"组件化，热修复实现原理"},"children":[]},{"data":{"id":"c45i89sx9eo0","created":1594644307882,"text":"Dagger依赖注入 "},"children":[]},{"data":{"id":"c45i8x6gpps0","created":1594644358767,"text":"OKhttp3的使用，网络请求中的原理intercept"},"children":[]},{"data":{"id":"c45i8x9dhsw0","created":1594644358943,"text":"Retrofit的实现与原理"},"children":[]},{"data":{"id":"c45i8xdd1vs0","created":1594644359184,"text":"Glide加载原理，缓存方案，Lru算法 "},"children":[]},{"data":{"id":"c45i92ot5e80","created":1594644370760,"text":"IPC机制(进程间通信)"},"children":[]}]},{"data":{"id":"c45he9bw0cw0","created":1594641955927,"text":"防坑"},"children":[]},{"data":{"id":"c45hecvphi80","created":1594641963656,"text":"其他"},"children":[]}]},"template":"right","theme":"snow","version":"1.4.33"}';

	window.onload=function(){
			editor.minder.importData("json", content).then(function (data) {
			console.log(data)
			$(fileInput).val('');
		});
	}

</script>
</html>
